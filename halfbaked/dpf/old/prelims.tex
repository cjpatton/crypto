% prelims.tex
%
% Notation, games, queues, syntax of protocols, and communication model.
% Definition of PROTO.
\label{sec-prelims}

\heading{Notation.}
Let $x \getsr S$ denote sampling an element~$x$ uniformly from a set~$S$.
%
If~$A$ is an algorithm, let $y \gets A(x_1, \ldots)$ denote running~$A$ on input
$x_1, \ldots$ and halting with output $y$.
%
Let $y \gets A(x_1, \ldots; \coins)$ denote running~$A$ with coins~$\coins$.
Let $y \getsr A(x_1, \ldots)$ denote sampling coins~$\coins$ uniformly and
letting $y = A(x_1, \ldots; \coins)$.
%
Let $[A(x_1, ...)]$ denote the set of possible outputs of $A$ run on input
$(x_1, \ldots \,; \coins)$ and with randomly sampled~$\coins$.
%
Let $[i..j] = \{ \ell \in \Z : i \le \ell \le j \}$ and $[n] = [1..n]$.
%
If~$\vecv$ is a vector, let~$\vecv[i]$ denote its~$i$-th element. Similarly,
if~$X$ is a string, let~$X[i]$ denote the~$i$-th bit of string~$X$.
%
Let~$\emptystring$ denote the empty string.
%
Let~$X \cat Y$ denote the concatenation of strings~$X$ and~$Y$.
%
If~$X$ and~$Y$ are equal length strings, let~$X \xor Y$ denote their
bitwise-xor.
Let~$\str{x}$ denote the invertible encoding of the arbitrary quantity~$x$ as a
string.
%
We say a sequence~$\vecv$ is indexed by a totally-ordered set~$S$ if $\vecv =
(v_{x_1}, \ldots, v_{x_n})$ where $(x_1, \ldots x_n)$ is the total ordering of
the elements of~$S$. This is denoted $(v_x)_{x\in S}$. Every set in this paper
has a total ordering.

\heading{Games.}
We adopt the game-playing framework of~\cite{games} with one exception: unless
otherwise stated, if a variable is undefined, then it is implicitly equal to the
formal symbol~$\bot$.~\cptodo{Double check if this is actually an exception.}

\heading{Queues.}
It will be convenient to use queues in our treatment of verifiable DPF schemes.
A queue~$Q$ is a first-in, first-out data structure with two methods.
%
By $Q.\enqueue(X)$ we mean add~$X$ to the top of~$Q$. If $Q=\bot$, then
$Q.\enqueue(X)$ means to instantiate a queue~$Q$ with~$X$ as its only element.
%
By $Q.\dequeue()$ we mean remove the element~$X$ from the bottom of~$Q$ and
return~$X$. If $Q = \bot$, then $Q.\dequeue()$ returns~$\bot$.

\subsection{Protocols}
We formalize protocols as a pair of probabilistic algorithms $\protocol =
(\init, \proto)$ with an associated set of principals~$P$.
%
Algorithm~$\init$ outputs a sequence of strings $(K_u)_{u\in P}$ called the
\emph{long-term inputs}.
%
Algorithm~$\proto$ dictates the actions of the principals at each step
of the protocol. It has the following inputs (all values are strings unless
otherwise noted):
\begin{itemize}
  \item[$u$] -- the identity of the receiver of~$X$, one of~$P$;
  \item[$w$] -- the identity of the alleged sender of~$X$, one of~$P$;
  \item[$i$] -- an identifier for the \emph{session}, an instance of the
    protocol. Either a string or the formal symbol~$\sess$;
  \item[$K$] -- the long-term input of~$u$ generated by $\init$;
  \item[$X$] -- the public input allegedly sent by~$w$; and
  \item[$\st$] -- the private state of the sender.
\end{itemize}
It has the following outputs:
\begin{itemize}
  \item[$Y$] -- the public output, the message to be sent out.
  \item[$v$] -- the identity of the intended recipient of $Y$ or $\bot$ if no
    message is sent.
  \item[$\verdict$] -- the sender's verdict, one of $\accept$, $\reject$, or
    $\bot$; and
  \item[$\st^\prime$] -- private state of~$u$ after processing the
    input.
\end{itemize}
By $(Y, v, \verdict, \st^\prime) \getsr \proto(u, w, i, K, X, \st)$ or
$(Y, v, \verdict, \st^\prime) \getsr \proto_{u,w}^i(K, X, \st)$ we denote the
execution of principal~$u$ on receipt of message~$X$, allegedly sent from~$w$,
in session~$i$. This causes the state of principal~$u$ in session~$i$ to
transition from~$\st$ to~$\st^\prime$.
%
Let~$\verdict_u^{i}$ denote the verdict of the last output of ~$u$ in
session~$i$. We say this session \emph{accepts} if for every $u \in P$, it holds
that $\verdict_u^{i} = \accept$.  Similarly, we say this session \emph{rejects}
if for every $u \in P$, it holds that $\verdict_u^{i} = \reject$.

\subsection{Communication model}\label{sec-com}
Protocols have two phases. In the \emph{initialization} phase, algorithm
$(K_u)_{u\in P} \getsr \init$ is run and the long-term inputs are
distributed to the principals. We assume the adversary is oblivious to this
process.
%
In the \emph{execution} phase, an instance of the protocol is carried out in the
presence of the adversary.
%
Bellare and Rogaway \cite{protos} model an adversary that controls
the network infrastructure by giving the adversary an oracle defined as follows:
%
on input $(u, w, i, X)$, first run $(Y, v, \verdict, \st_{u}^i) \getsr
\proto_{u,w}^i(K_u, X, \st_{u}^i)$ where $K_u$ is the long-term input of $u$
generated in the initialization phase and $\st_{u}^i$ is initially
$\emptystring$. Then return $(Y, v, \verdict)$ to the adversary.
%
Implicit in the formalization of any protocol is the existence of a so-called
\emph{benign adversary}, which faithfully relays the messages according to
specification, causing each session to accept.

In our treatment of verifiable DPF schemes, it will be useful to consider a more
robust communication model.  First, we would like to be able to model a weaker
adversary who does not observe all network flows, but only those along paths
under its control. Second, it will be useful for formalizing certain properties
of our protocols to allow each principal to be given a \emph{private input} in
addition to the long-term input generated by $\init$.
%
Essentially we need a technical means to allow the adversary to induce a
principal to process a message it did not explicitly send. Thus, we introduce a
\emph{message queue} for each principal and session.
%
The adversary is given a pair of oracles, one for enqueueing messages and
another for dequeueing them. Messages on the queue are accompanied by an alleged
sender. (The adversary need not control the network in order to send a
principal a message and fake the sender; IP address spoofing makes this
trivial.) When a message is dequeued, the corresponding principal is executed on
the incoming message. If the adversary is on path to the intended recipient of
the output message, then the adversary is given the principal's output message
and the identity of the recipient; otherwise the message and sender are added to
the top of the recipient's queue.

\heading{\protosec.}
\begin{figure}[t]
  \twoColsNoDivide{0.45}
  {
    \underline{$\game{\protosec}_{\protocol,I,O}(\advA)$}\\[2pt]
      $(K_u)_{u\in P} \getsr \protocol.\init$\\
      for each $u \in P$ do\\
      \ind if $I(u) \ne \bot$ then $Q_u^\sess \gets Q_u^\sess.\enqueue(I(u))$\\
      $\advA^{\ENQO,\DEQO}$\\
      if $\sess$ accepts then return $\accept$
  }
  {
    \underline{$\ENQO_{u,w}^i(X)$}\\[2pt]
      $Q_u^i.\enqueue(X, w)$
    \\[6pt]
    \underline{$\DEQO_u^i()$}\\[2pt]
      $(X, w) \gets Q_u^i.\dequeue()$\\
      $(Y, v, \verdict, \st_u^i) \getsr \protocol.\proto_{u,w}^i(K_u, X, \st_u^i)$\\
      if $v \in O$ then return $(Y, v, \verdict)$\\
      else if $v \ne \bot$ then $Q_v^i.\enqueue(Y, u)$\\
      return $(\bot, v, \verdict)$
  }
  \caption{A game modeling the execution of a protocol $\protocol$ with
  principals $P$ where adversary $\advA$ controls the network. Each $\st_u^i$ is
  initially $\emptystring$.}
  \vspace{6pt}\hrule
  \label{fig-proto}
\end{figure}
We formalize this communication model in Figure~\ref{fig-proto} in a game
associated to protocol~$\protocol$ with principal set~$P$,
adversary~$\advA$,
map $I : P \to \bits^* \by P$, and
set $O \subseteq P$.
% I
The quantity $I(u)$ is a pair $(X, w)$ where~$X$ is called the \emph{private
input} of $u\in P$ and~$w$ is the alleged sender of~$X$. Note that $I(u)$ need
not be defined for every $u \in P$.
% O
The set~$O$ denotes the set of principals who's incoming messages can be
intercepted by the adversary. If $v \in O$, we say that~$\advA$ is \emph{on
path} to~$v$.
%
We maintain a queue $Q_u^i$ for every principal $u \in P$ and every session $i$
instantiated by the adversary, as well as a special session $\sess$ instantiated
by the game.
%
The game begins by running the initialization algorithm and furnishing each
principal with its private input. For every $u \in P$ for which~$I(u)$ is
defined, the pair~$I(u)$ is added to the top of the queue~$Q_u^\sess$.
%
Next, the adversary is given access to two oracles. On input $(u, w, i, X)$,
oracle~$\ENQO$ adds $(X, w)$ to the top of~$Q_u^i$. On input $(u, i)$,
oracle~$\DEQO$ removes $(X, w)$ from the bottom of~$Q_u^i$ and executes~$u$ on
input~$X$, allegedly sent from~$w$, and updates the state~$\st_u^i$ (initially
~$\emptystring$). Let $(Y, v, \verdict, \st_u^i)$ denote the output.
If the adversary is on path to~$v$, then $(Y, v, \verdict)$ is given to the
adversary. Otherwise, the adversary only gets~$v$ and~$\verdict$.  Finally, the
game outputs~$\accept$ if session~$\sess$ accepts.

Following \cite{protos}, we implicitly assume, for a particular protocol
$\protocol$,  the existence of a benign adversary who always causes the game to
output $\accept$ for ``valid'' initial inputs $I$.  We remark that ours is a
generalization of their model.  In particular, if $I(u) = \bot$ for every $u \in
P$ and $O = P$, then this game is equivalent to the communication model of
Bellare and Rogaway.
